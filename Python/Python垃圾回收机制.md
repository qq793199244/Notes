## Python垃圾回收（GC）机制 
**引用计数为主，标记-清除、分代回收为辅。**  
Python的GC模块主要通过“引用计数”来跟踪和回收垃圾。在“引用计数”的基础上，通过“标记-清除”来解决容器对象可能产生的**循环引用**问题，通过“分代回收”来实现**以空间换时间**，进一步提高垃圾回收的效率。  
### 1. 引用计数  
- 当一个对象的引用被创建或复制时，对象的引用计数加1；
- 当一个对象的引用被销毁时，对象的引用计数减1；
- 如果对象的引用计数减少为0，则意味着没被任何引用，可将其所占用的内存地址释放。  

必须在**每次分配和释放内存时**加入管理引用计数的动作。  
**最大优点**：实时性。任何内存地址，一旦没有指向它的引用，就会立即被回收。

### 2. 标记-清除——为了解决循环引用问题  
可以包含其他对象引用的容器对象（如list、set、dict、class、instance都可产生循环引用）。  
若两个对象的引用计数都为1，而它们之间仅仅存在循环引用，则这两个对象都需要被回收。因为虽然它们的引用计数表现非0，但实际有效引用计数为0，“标记-清除”机制++并不改动真实的引用计数++，而是++将集合中对象的引用计数复制一份副本++，++改动该对象引用的副本++，对于副本所做任何的改动，都不会影响对象生命周期的维护。
### 3. 分代回收
“标记-清除”机制带来的**额外操作**与系统中**内存块的数量**相关。需要回收的内存块越多，则垃圾检测需要的额外操作就越多，而垃圾回收需要的额外操作就越少；
需要回收的内存块越少，则垃圾检测需要的额外操作就越少，而垃圾回收需要的额外操作就越多。  
为了提高垃圾回收效率，可采用“**以空间换时间**”策略。  
**原理**：将系统中所有内存块根据其存活时间划分为不同的集合，每一个集合是一“代”，垃圾回收的频率随着“代”的存活时间的增大而减小，即活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾回收频率。   
**衡量存活时间**：若一个对象经过的垃圾回收次数越多，则可以得出该对象的存活时间越长。