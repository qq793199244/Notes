####  TCP 建立连接的过程（三次握手）
![image](https://note.youdao.com/yws/public/resource/54fc0eceff7ffb19ad7baeffb2dee958/xmlnote/92759B4A999445DF8027623B4E1145AC/9075){:height="50%" width="50%"}
最初客户端和服务器端都处于 **CLOSED** (关闭)状态，客户端主动打开连接，服务端被动打开连接。  
服务端创建传输控制块 TCB ，服务端处于  **LISTEN** (监听)状态，等待客户端的连接请求，如果有，即作出相应。  
**第一次握手**，客户端创建传输控制块 TCB ，向服务端发出连接请求报文段，这时首部中的同步位 SYN=1 ，同时选择一个初始序号 seq=x 。 TCP 规定，SYN 报文段（即 SYN=1 的报文段）不能携带数据，但要**消耗掉一个序号**。这时客户端进入 **SYN-SENT** (同步已发送)状态。  
**第二次握手**，服务端收到连接请求后，如果同意建立连接，则向客户端发送确认。在确认报文段中 SYN=1 , ACK=1 ，确认号是 ack=x+1 ，同时也为自己选择一个初始序号 seq=y 这个确认报文段也不能携带数据但同样**要消耗掉一个序号**。这时服务端进入 **SYN-RCVD** (同步收到)状态。  
**第三次握手**，客户端收到服务端的确认后，还要向服务端给出确认。确认报文段的 ACK=1 ，确认号  ack=y+1 ，自己的序列号 seq=x+1 。 TCP 的标准规定， ACK 报文段可以携带数据，但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq=x+1 。    
这时TCP连接已经建立，客户端进入 **ESTABLISHED** (已建立连接)状态，当服务端收到客户端的确认后也进入 **ESTABLISHED** (已建立连接)状态。  

#### 为什么客户端最后还要发送一次确认？
这主要是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。  
**在正常情况下**，当客户端发出连接请求，但因连接请求报文段丢失而未收到确认。于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。**客户端共发送了两个请求连接报文段，其中第一个丢失，第二个到达了服务端，此时没有“已失效的连接请求报文段”**。  
现假定出现了一种**异常情况**，即客户端发送的第一个请求连接报文段并没有丢失，而是在某些网络结点长时间滞留了，以致**延误到连接释放以后的某个时间才到达服务端**。这本来是一个早已失效的报文段，但服务端收到这个失效的连接请求报文段后，**误认为**是客户端又发送了一次**新的连接请求**，于是就向客户端发送确认报文段，同意建立连接。如果不采用三次握手，那么只要服务器发出确认，连接就建立了。  
但**实际上客户端并没有发送新的建立连接的请求**，因此不会理睬服务端的确认，也不会向服务端发送数据。**但服务端却认为连接已经建立**了，并一直等待客户端发来数据。服务端的许多资源就这样白白浪费了。

#### 为什么是三次握手，为什么不是两次、四次？
1. 三次握手才可以**阻止重复历史连接的初始化**（主要原因）  
在网络拥堵等情况下，如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接。
2. 三次握手才可以**同步双方的初始序列号**  
**序列号**在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带**初始序列号**的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送**初始序列号**给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
- 两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
- 四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步（ACK=1, ack=x+1）和第三步（SYN=1, seq=y）可以优化成一步，所以就成了三次握手。


3. 三次握手可以**避免资源浪费**  
如果只有两次握手，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN  ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接。如果客户端的 SYN 阻塞了，重复发送多次 SYN  报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。