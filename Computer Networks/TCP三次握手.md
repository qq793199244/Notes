####  TCP 建立连接的过程（三次握手）
![image](https://note.youdao.com/yws/public/resource/54fc0eceff7ffb19ad7baeffb2dee958/xmlnote/92759B4A999445DF8027623B4E1145AC/9075)
最初客户端和服务器端都处于 **CLOSED** (关闭)状态，客户端主动打开连接，服务端被动打开连接。  
服务端创建传输控制块 TCB ，服务端处于  **LISTEN** (监听)状态，等待客户端的连接请求，如果有，即作出相应。  
**第一次握手**，客户端创建传输控制块 TCB ，向服务端发出连接请求报文段，这时首部中的同步位 ==SYN=1== ，同时选择一个初始序号 ==seq=x== 。 TCP 规定，SYN 报文段（即 SYN=1 的报文段）不能携带数据，但要**消耗掉一个序号**。这时客户端进入 **SYN-SENT** (同步已发送)状态。  
**第二次握手**，服务端收到连接请求后，如果同意建立连接，则向客户端发送确认。在确认报文段中 ==SYN=1== , ==ACK=1== ，确认号是 ==ack=x+1== ，同时也为自己选择一个初始序号==seq=y== 这个确认报文段也不能携带数据但同样**要消耗掉一个序号**。这时服务端进入 **SYN-RCVD** (同步收到)状态。  
**第三次握手**，客户端收到服务端的确认后，还要向服务端给出确认。确认报文段的 ==ACK=1== ，确认号 ==ack=y+1== ，自己的序列号 ==seq=x+1== 。 TCP 的标准规定， ++ACK 报文段可以携带数据，但如果不携带数据则不消耗序号++，在这种情况下，下一个数据报文段的序号仍是 seq=x+1 。    
这时TCP连接已经建立，客户端进入 **ESTABLISHED** (已建立连接)状态，当服务端收到客户端的确认后也进入 **ESTABLISHED** (已建立连接)状态。  

#### 为什么客户端最后还要发送一次确认？
这主要是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。  
在正常情况下，当客户端发出连接请求，但因连接请求报文段丢失而未收到确认。于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端共发送了两个请求连接报文段，其中第一个丢失，第二个到达了服务端，此时没有“已失效的连接请求报文段”。  
现假定出现了一种异常情况，即客户端发送的第一个请求连接报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务端。这本来是一个早已失效的报文段，但服务端收到这个失效的连接请求报文段后，误认为是客户端又发送了一次新的连接请求，于是就向客户端发送确认报文段，同意建立连接。如果不采用三次握手，那么只要服务器发出确认，连接就建立了。  
但实际上客户端并没有发送新的建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据。但服务端却认为连接已经建立了，并一直等待客户端发来数据。服务端的许多资源就这样白白浪费了。

#### 为什么是三次握手，为什么不是两次、四次？
1. 三次握手才可以阻止重复历史连接的初始化（主要原因）
2. 三次握手才可以同步双方的初始序列号
3. 三次握手可以避免资源浪费 
