### 并发事务带来哪些问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepeatable read）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

#### 不可重复读和幻读区别：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。


## 数据库的事务隔离级别

### 数据库的事务隔离级别有哪些？各有哪些优缺点？
- **读未提交 read-uncommitted**

  最低级别，任何情况都无法保证。

  这种事务隔离级别下， select 语句不加锁。此时，可能读取到不一致的数据，即“读脏”。这是并发最高，一致性最差的隔离级别。
- **读已提交 read-committed**

   可避免脏读的发生。
- **可重复读 repeatable-read**

   MySQL 默认隔离级别。可避免脏读、不可重复读的发生。
- **串行化 serializable**

  可避免脏读、不可重复读、幻读的发生。

以上四种隔离级别最高的是 serializable 级别，最低的是 read-uncommitted 级别，**级别越高执行效率就越低**。像 serializable 这样的隔离级别，就是以锁表的方式 (类似于 Java 多线程中的锁) 使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

在 MySQL 数据库中默认的隔离级别为 repeatable-read (可重复读)；而在 Oracle 数据库中，只支持 serializable (串行化)级别和 read-committed (读已提交)这两种级别，其中默认的为 read-committed 级别。

### 事务隔离级别与锁的关系
| 隔离级别         | 锁                                               |
| ---------------- | ------------------------------------------------ |
| read-uncommitted | 读取无需加共享锁                                 |
| read-committed   | 读操作需要加共享锁，**语句**执行完毕后释放       |
| repeatable-read  | 读操作需要加共享锁，**事务**执行完毕后释放       |
| serializable     | **锁定整个范围的键**，并一直持有锁，直到事务完成 |
