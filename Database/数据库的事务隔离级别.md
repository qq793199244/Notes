## 数据库的事务隔离级别

### 数据库的事务隔离级别有哪些？各有哪些优缺点？
1. **读未提交 read-uncommitted**

  最低级别，任何情况都无法保证。

  这种事务隔离级别下， select 语句不加锁。此时，可能读取到不一致的数据，即“读脏”。这是并发最高，一致性最差的隔离级别。
2. **读已提交 read-committed**

   可避免脏读的发生。
3. **可重复读 repeatable-read**

   MySQL 默认隔离级别。可避免脏读、不可重复读的发生。
4. **串行化 serializable**

  可避免脏读、不可重复读、幻读的发生。

以上四种隔离级别最高的是 serializable 级别，最低的是 read-uncommitted 级别，**级别越高执行效率就越低**。像 serializable 这样的隔离级别，就是以锁表的方式 (类似于 Java 多线程中的锁) 使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

在 MySQL 数据库中默认的隔离级别为 repeatable-read (可重复读)；而在 Oracle 数据库中，只支持 serializable (串行化)级别和 read-committed (读已提交)这两种级别，其中默认的为 read-committed 级别。

### 事务隔离级别与锁的关系
| 隔离级别          | 锁                |
| ---------------- | ------------------------------------ |
| read-uncommitted | 读取无需加共享锁                       |
| read-committed   | 读操作需要加共享锁，**语句**执行完毕后释放 |
| repeatable-read  | 读操作需要加共享锁，**事务**执行完毕后释放 |
| serializable     | **锁定整个范围的键**，并一直持有锁，直到事务完成 |
