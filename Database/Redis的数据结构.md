### Redis 的数据结构
#### Redis 有几种数据结构？
字符串 String 、列表 List 、哈希 Hash 、 集合 Set 、有序集合 ZSet ( Sorted Set ) 。

#### Zset 是如何实现的？
 Zset 内部是通过一种名为**跳跃表** ( SkipList ) 的数据结构来实现的。
Redis 使用跳跃表作为有序集合键的的底层实现，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。
 Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。

##### 跳跃表的基本思想
通过将有序集合的部分节点分层，由最上层开始依次向后查找，如果本层的 next 节点大于要查找的值或 next 节点为 NULL ，则从本节点开始，降低一层继续向后查找，依次类推，如果找到则返回节点；否则返回 NULL 。采用该原理查找节点，在节点数量比较多时，可以跳过一些节点，查询效率大大提升，这就是跳跃表的**基本思想**。

 跳跃表的数据结构为：
 ```
 typedef struct zskiplist {
    // 表头结点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
 ```
 - ```header``` ：指向跳跃表的表头节点。头节点是跳跃表的一个特殊节点，它的 ```level``` 数组元素个数为 64 。头节点在有序集合中不存储任何 member 和 score 值， ele 值为 NULL ， score 值为 0 ；也不计入跳跃表的总长度。头节点在初始化时， 64 个元素 forward 都指向 NULL ， span 值都为 0 。
 - ```tail``` ：指向跳跃表的表尾节点
 - ```level``` ：记录目前跳跃表内层数最大的那个节点的层数(表头除外)，获取表头和表尾时间复杂度为 O(1)
 - ```length``` ：记录跳跃表的长度跳跃表目前包含节点的数量(表头除外)，获取有序集合的时间复杂度为 O(1)
 > 将包含给定成员和分值的新节点**添加**到跳跃表中；**删除**跳跃表中包含给定成员和分值的节点；返回包含给定成员和分值的节点在跳跃表中的**排位**；返回跳跃表在给定排位上的节点。以上操作的平均时间复杂度 O(logN) ，最坏时间复杂度 O(N) 。

跳跃表节点的数据结构为：
```
typedef struct zskiplistNode {
    sds ele;
    // 分值
    double score;
    // 后退指针
    struct zskiplistNode *backward;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```
该结构体包含如下属性：
- ```ele``` ：用于存储字符串类型的数据。
- ```score``` ：用于存储排序的分值。
- ```backward``` ：后退指针，只能指向当前节点最底层的前一个节
点，头节点和第一个节点—— backward 指向 NULL ，从后向前遍历跳跃
表时使用。
- ```level``` ：为柔性数组。每个节点的数组长度不一样，在生成跳
跃表节点时，随机生成一个 1～64 的值，值越大出现的概率越低。

    ```level``` 数组的每项包含以下两个元素。
    - ```forward``` ：指向本层下一个节点，尾节点的 forward 指向 NULL 。
    - ```span``` ：forward 指向的节点与本节点之间的元素个数。 span 值越
    大，跳过的节点个数越多。

跳跃表是 Redis 有序集合的底层实现方式之一，所以每个节点的 ele 存储有序集合的成员 member 值， score 存储成员 score 值。所有节点
的分值是按从小到大的方式排序的，当有序集合的成员分值相同时，节点会按member的字典序进行排序。



##### ZSet 的底层实现为什么不用其他数据结构
对于有序集合的底层实现，我们可以使用数组、链表、平衡树等结构。数组不便于元素的插入和删除；链表的查询效率低，需要遍历所有元素；平衡树或者红黑树等结构虽然效率高但实现复杂。 Redis 采用了一种新型的数据结构——跳跃表。跳跃表的效率堪比红黑树，然而其实现却远比红黑树简单。
 Redis 使用跳跃表作为有序集合键的的底层实现，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。
