### 锁
使用加锁操作和解锁操作可以解决并发进程/线程的互斥问题。

任何想进入临界区的资源，必须先进行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再进行解锁操作，以释放该临界资源。

根据锁的实现不同，可以分为**忙等待锁**和**无忙等待锁**。

当获取不到锁时，线程会一直while循环，不做任何事情，被称为忙等待锁，也被称为**自旋锁**。这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU 。

无忙等待锁就是获取不到锁的时候，不用自旋。当没获取到锁的时候，就把当前线程放入到**锁的等待队列**，然后执行调度程序，把 CPU 让给其他线程执行。

### 死锁
在多线程编程中，为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么当这两个互斥锁使用不当时，可能会造成**两个线程都在等待对方释放锁**，在没有外力的作用下，这些线程会一直互相等待，无法继续运行，这种情况就是发生了**死锁**。

#### 死锁产生的四个条件
1. **互斥条件**
 > 多个线程不能同时使用同一个资源。
2. 持有并等待条件
 > 当线程 A 已经持有了资源 1 ，又想申请资源 2 ，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是**线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1**。
3. 不可剥夺条件
  > 当线程已经持有了资源，**在自己使用完之前不能被其他线程获取**，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
4. 环路等待条件
  > 在死锁发生时，**两个线程获取资源的顺序构成了环形链**。

#### 死锁的避免
避免死锁只需要破坏四个产生死锁的条件其中的一个即可，最常见的且可行的是**使用资源有序分配法，来破坏环路等待条件**。
> 资源有序分配法？
  线程 A 和线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A ，然后再尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A ，然后尝试获取资源 B 。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

### 各种锁
#### 互斥锁、自旋锁、读写锁、乐观锁、悲观锁
加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。

互斥锁和自旋锁是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。

当已经有一个线程加锁后，其他线程加锁就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：
- **互斥锁**加锁失败或，线程会**释放 CPU** ，给其他线程，切换线程；
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁。

##### 互斥锁

**互斥锁是一种独占锁**。比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占，只要线程 A 没有释放手中的锁，线程 B 就会加锁失败，于是就会释放 CPU 让给其他线程，既然**线程 B 释放掉了 CPU ，自然线程 B 加锁的代码就会被阻塞**。对互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为**睡眠**状态，等待锁被释放后，内核会在何时的时机唤醒线程，当这个线程成功获取到锁后，就可以继续执行。

互斥锁加锁失败时，会**从用户态陷入到内核态**，让内核帮助切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。
这个开销成本是，**两次线程上下文切换的成本**：
- 当线程加锁失败时，内核会把线程的状态**从运行状态设置为睡眠状态**，然后把 CPU 切换给其他线程运行；
- 接着，当锁被释放时，之前**睡眠状态的线程会变为就绪状态**，然后内核会在合适的时间，把 CPU 切换给该线程运行。

线程的上下文切换的是什么？当两个线程是同属于一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

如果锁住的代码执行时间较短，那可能上下文切换的时间比锁住的代码执行时间还要长。所以，**如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁**。

##### 自旋锁
自旋锁是通过 CPU 提供的 ```CAS``` 函数（ Compare And Swap），在用户态完成加锁和解锁的操作，不会主动产生线程上下文切换。相比互斥锁更快，开销也小。

一般加锁的过程，包含两个步骤：
- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
- 第二步，将锁设置为当前线程持有。

```CAS``` 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

使用自旋锁时，当发生多线程竞争锁的情况，加锁失败的线程会**忙等待**，直到它拿到锁。这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU 。

自旋锁开销少，在多核系统下一般不会产生线程切换，适合异步、协程等在用户态切换请求的编程方式。但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行时间是成**正比**的关系。

##### 读写锁
读写锁由读锁和写锁两部分构成，如果只读取共享资源用读锁加锁，如果要修改共享资源则用写锁加锁。
读写锁适用于**能明确区分读操作和写操作的场景**。

读写锁的**工作原理**是：
- 当写锁没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率。因为读锁适用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦写锁被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会变阻塞。

所以，**写锁是独占锁**，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁；而**读锁是共享锁**，因为读锁可以被多个线程同时持有。**读写锁在读多写少的场景能发挥出优势**。

根据实现的不同，读写锁可以分为读优先锁和写优先锁。

**读优先锁的期望**是，读锁能被更多的线程持有，以便提高读线程的并发性，其**工作方式**是：当读线程 A 先持有了读锁，写线程 B 在获取写锁时，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。

**写优先锁**是优先服务写进程，其**工作方式**是：当读进程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。

**公平读写锁**比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现**饥饿**的现象。

##### 乐观锁与悲观锁

互斥锁、自旋锁、读写锁都属于悲观锁。

**悲观锁**做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

相反，如果多线程同时修改共享资源的概率较低，就可以采用乐观锁。

乐观锁做事比较乐观，它假定冲突的概率很低。它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成；如果发现有其他线程已经修改过这个资源，就放弃本次操作**。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时才考虑使用乐观锁**。


不管使用哪种锁，加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快，再使用合适的锁，就会快上加快。
