### 递归
#### 递归的三大要素
①明确这个函数想要干什么  
②寻找递归结束条件  
③找出函数的等价关系式

#### 案例一：斐波那契数列
> 斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。
##### ① f(n) 的功能是求第n项的值

```
def f(n):
    ...
```
##### ② 递归结束条件是 n<=2
```
def f(n):
    if n<=2:
        return 1
    ...
```
##### ③函数的等价关系式
题目已经把等价关系式给了，所以很容易就能够知道 f(n) = f(n-1) + f(n-2)。
```
def f(n):
    if n<=2:
        return 1
    return f(n-1) + f(n-2)
```

#### 案例二：小青蛙跳台阶
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
##### ①函数功能是求青蛙跳上一个 n 级的台阶总共有多少种跳法

```
def f(n):
    ...
```
##### ②递归结束条件，当 n=1 时，f(1)=1
```
def f(n):
    if n == 1:
        return 1
```
##### ③函数的等价关系式
每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。
- 第一种跳法：第一次我跳了一个台阶，那么还剩下 n-1 个台阶还没跳，剩下的n-1个台阶的跳法有 f(n-1) 种。
- 第二种跳法：第一次跳了两个台阶，那么还剩下 n-2 个台阶还没，剩下的 n-2 个台阶的跳法有 f(n-2) 种。

所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。
```
def f(n):
    if n == 1:
        return 1
    return f(n-1) + f(n-2)
```
上面代码存在问题，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入**死循环**。  
这里规定好 f(0) 等于 0 还是等于 1 。  
**递归结束条件是否够严谨**，当在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。
```
def f(n):
    # 这里按 f(0) = 1算的
    if n <= 1:
        return 1
    return f(n-1) + f(n-2)
```

#### 案例三：反转链表
> 反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1

链表结点定义如下：
```
Class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```
##### ① f(n) 的功能是求反转后的链表

```
def reverseList(head):
    ...
```
##### ②递归的终止条件
当链表只有一个节点，或链表为空，直接返回 head 。
```
def reverseList(head):
    if not head or not head.next:
        return head
    ...
```
##### ③函数的等价关系式
reverseList(head) 等价于 reverseList(head.next) + 改变一下1，2两个节点的指向。
> 递归求解本题理解上有一定的难度，主要需要搞清楚定义的递归函数F(n)的意义。  
本题中F(n)定义为：反转头为n的链表，并返回新的表头，也就是原链表的最后一个节点；   
那么F(n.next)的含义为：反转头为n.next的链表，并返回新的表头。  
接下来要想清楚已知F(n.next)的条件下，如何得到F(n)。
注意F(n）和F(n.next）的表头是一致的，所以直接返回就好。关键问题是将n.next指向n，即进行以下操作：  
n.next.next = n  
n.next = None

```
def reverseList2(head):
    # 递归终止条件
    if not head or not head.next:
        return head
    # 反转后的链表表头
    newHead = reverseList(head.next)
    # 反转指针
    head.next.next = head
    # head.next为None表明此时head为原链表最后一个元素
    head.next = None
    return newHead
```

### 递归的优化
#### 1. 考虑是否存在重复计算
备忘录，可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。

当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。

#### 2. 考虑是否可以自底向上，递推
例如：  
f(1) = 1;  
f(2) = 2;  
那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。